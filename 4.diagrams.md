```plantuml
graph TB
    Client
    
    WebSocket

    GW[API Gateway]
    LB[Load Balancer]

    

    subgraph "Микросервисы"
        Auth[Auth Service]
        User[User Service]
        Post[Post Service]
        Feed[Feed Service]
        Comment[Comment Service]
        EventP[Event Processor]
        Notif[NotificationService]
    end

    subgraph "Шина событий"
        Kafka[Kafka Cluster]
    end

    subgraph "Хранилища данных"
        PG[PostgreSQL]
        Cassandra[Cassandra Cluster]
        Redis[Redis Cluster]
    end

    Client --> LB
    LB --> GW
    
    Notif --> WebSocket
    WebSocket --> Client
    Kafka --> Notif

    GW --> Auth
    GW --> User
    GW --> Post
    GW --> Feed
    GW --> Comment
    
    User --> PG
    User --> Redis
    
    Post --> PG
    Post --> Redis
    Post --> Kafka

    Feed --> Cassandra
    Feed --> Redis
    Feed --> Post
    
    Comment --> Cassandra
    Comment --> Kafka
    Comment --> Redis
    
    EventP --> Kafka
    EventP --> Cassandra
    EventP --> PG
    EventP --> Redis

    style Client fill:#e1f5e1
    style GW fill:#f5f5dc
    style Comment fill:#ffccbc
    style EventP fill:#f8bbd0
    style Kafka fill:#ffecb3
    style PG fill:#c8e6c9
    style Cassandra fill:#ffccbc
    style Redis fill:#ffcdd2
```

Deployment
```plantuml
---
config:
    layout: elk.stress
---
graph TB
    subgraph "Публичное облако"
        subgraph "Load Balancing"
            LB[Load Balancer<br/>AWS ALB/NLB<br/>Auto-scaling group]
        end
        
        subgraph "Application"
            subgraph "API Gateway Cluster"
                API1[API Gateway<br/>Pod 1]
                API2[API Gateway<br/>Pod 2]
                API3[API Gateway<br/>Pod 3]
            end
            
            subgraph "Microservices Cluster"
                FS1[Feed Service<br/>Pod 1-5]
                PS1[Post Service<br/>Pod 1-3]
                CS1[Comment Service<br/>Pod 1-4]
                US1[User Service<br/>Pod 1-2]
                NS1[Notification Service<br/>Pod 1-2]
            end
            
            subgraph "Workers Cluster"
                W1[Outbox Worker<br/>Pod 1-3]
                W2[Fan-out Worker<br/>Pod 1-5]
            end
        end
        
        subgraph "Data"
            subgraph "Cache Layer"
                RC[Redis Cluster]
            end
            
            subgraph "Message Queue"
                KF[Kafka Cluster]
            end
            
            subgraph "NoSQL Database"
                CC[Cassandra Cluster]
            end
            
            subgraph "SQL Database"
                PG[PostgreSQL]
            end
            
        end
        
        subgraph "Client"
            WB[Mobile/Web Browser<br/>HTTP/2, WebSocket]
        end
    end
    
    %% Connections
    WB --> LB
    
    LB --> API1
    LB --> API2
    LB --> API3
    
    API1 --> FS1
    API1 --> PS1
    API1 --> CS1
    API1 --> US1
    
    API2 --> FS1
    API2 --> PS1
    API2 --> CS1
    API2 --> US1
    
    API3 --> FS1
    API3 --> PS1
    API3 --> CS1
    API3 --> US1
    
    FS1 --> RC
    FS1 --> CC
    FS1 --> PG
    
    PS1 --> PG
    PS1 --> KF
    
    CS1 --> CC
    CS1 --> PG
    CS1 --> KF
    
    US1 --> PG
    US1 --> RC
    
    W1 --> PG
    W1 --> KF
    
    W2 --> KF
    W2 --> CC

    KF --> FS1
    KF --> NS1

    NS1 --> WB
        
    %% Data layer connections
    PG -.->|Streaming Replication| PG
    RC -.->|Cluster Replication| RC
    CC -.->|Cross-DC Replication| CC
    KF -.->|Replication Factor 3| KF
```

Data
```plantuml
classDiagram
    direction LR
    
    class User {
        <<Entity>>
        <<Table: users>>
        <<Indexes: email_unique>>
        -id: BIGSERIAL [PK]
        -email: VARCHAR(255) [NOT NULL, UK]
        -password: VARCHAR(255) [NOT NULL]
    }
    
    class Subscription {
        <<Entity>>
        <<Table: subscriptions>>
        <<Constraints: unique_follower_following>>
        -id: BIGSERIAL [PK]
        -follower_id: BIGINT [FK → User.id, NOT NULL]
        -following_id: BIGINT [FK → User.id, NOT NULL]
        -created_at: TIMESTAMPTZ [DEFAULT NOW()]
        -status: VARCHAR(20) [DEFAULT 'active']
    }
    
    class Post {
        <<Entity>>
        <<Table: posts>>
        <<Indexes: idx_author_created>>
        -id: BIGSERIAL [PK]
        -author_id: BIGINT [FK → User.id, NOT NULL]
        -content: TEXT
        -created_at: TIMESTAMPTZ [NOT NULL, DEFAULT NOW()]
        -updated_at: TIMESTAMPTZ [DEFAULT NOW()]
        -deleted_at: TIMESTAMPTZ [NULL]
    }
    
    class OutboxEvent {
        <<Entity>>
        <<Table: outbox_events>>
        <<Transactional Boundary>>
        <<Indexes: idx_unprocessed, idx_idempotency_key>>
        -id: BIGSERIAL [PK]
        -aggregate_type: VARCHAR(50) [NOT NULL]
        -aggregate_id: BIGINT [NOT NULL]
        -event_type: VARCHAR(50) [NOT NULL]
        -payload: JSONB [NOT NULL]
        -created_at: TIMESTAMPTZ [NOT NULL, DEFAULT NOW()]
        -processed: BOOLEAN [NOT NULL, DEFAULT false]
        -processed_at: TIMESTAMPTZ [NULL]
        -idempotency_key: UUID [UK]
        -retry_count: INTEGER [DEFAULT 0]
    }
    
    User "1" -- "*" Post 
    User "1" -- "*" Subscription 
    User "1" -- "*" Subscription 
    Post "1" -- "*" OutboxEvent 
    
    User "1" --> "*" Post 
    Post "*" --> "1" User 
    Subscription "*" --> "1" User 
    Subscription "*" --> "1" User 
    
    Post "1" *-- "*" OutboxEvent : outbox_events
```
публикация поста с Outbox и доставкой события;
```plantuml
sequenceDiagram
    actor User as Пользователь
    participant GW as API Gateway
    participant Auth as Auth Service
    participant PostS as Post Service
    participant PG as PostgreSQL
    participant EventP as Event Processor
    participant Kafka as Kafka
    participant FeedS as Feed Service
    participant Cassandra as Cassandra
    participant WS as WebSocket Manager

    User->>GW: POST /api/v1/posts
    GW->>Auth: validateToken(token)
    Auth-->>GW: user_id
    GW->>PostS: createPost(user_id, content)
    
    PostS->>PG: BEGIN TRANSACTION
    PostS->>PG: INSERT INTO posts(...)
    PG-->>PostS: post_id
    PostS->>PG: INSERT INTO outbox_events<br/>(aggregate_type='post',<br/>aggregate_id=post_id,<br/>event_type='created')
    PostS->>PG: COMMIT
    PostS-->>GW: 201 Created + post_id
    GW-->>User: 201 Created
    
    Note over EventP: Polling outbox каждые 100ms
    EventP->>PG: SELECT * FROM outbox_events<br/>WHERE processed=false LIMIT 100
    PG-->>EventP: список событий
    EventP->>PG: UPDATE outbox_events<br/>SET processed=true WHERE id IN (...)
    
    loop Для каждого события
        EventP->>Kafka: publish('post.created', {post_id, author_id, ...})
    end
    
    FeedS->>Kafka: consumer group 'feed-service'
    Kafka-->>FeedS: событие post.created
    FeedS->>PG: SELECT follower_id FROM subscriptions<br/>WHERE following_id=author_id
    PG-->>FeedS: список follower_ids
    
    par Для каждого подписчика
        FeedS->>Cassandra: INSERT INTO feeds (user_id, post_created_at, post_id, ...)
    end
    
    WS->>User: WebSocket сообщение
```

- чтение ленты с курсором и гидратацией;
```plantuml
sequenceDiagram
    actor User as Пользователь
    participant GW as API Gateway
    participant Auth as Auth Service
    participant FeedS as Feed Service
    participant Cassandra as Cassandra
    participant Redis as Redis Cache
    participant PostS as Post Service
    participant PG as PostgreSQL

    User->>GW: 
    GW->>Auth: validateToken(token)
    Auth-->>GW: user_id
    GW->>FeedS: getFeed(user_id, cursor, limit=20)
    
    FeedS->>Redis: GET feed_cache:{user_id}:{cursor}
    alt Кэш найден (TTL 5 минут)
        Redis-->>FeedS: cached_feed
        FeedS-->>GW: feed_items
        GW-->>User: 200 OK с данными
    else Кэш отсутствует
        FeedS->>Cassandra: 
        Cassandra-->>FeedS: список post_ids
        
        FeedS->>Redis: MGET post:{post_id}
        Redis-->>FeedS: кэшированные посты (частично)
        
        FeedS->>FeedS: extractMissingPostIds(cached, requested)
        FeedS->>PostS: batchGetPosts(missing_ids, batch_size=100)
        
        PostS->>Redis: MGET post:{post_id} (резервный кэш)
        Redis-->>PostS: частичные данные
        PostS->>PG: 
        PG-->>PostS: недостающие посты
        PostS->>Redis: MSET post:{id}=data (TTL 10 минут)
        PostS-->>FeedS: batch_posts
        
        FeedS->>FeedS: mergePosts(cached, batch)
        FeedS->>Redis: SET feed_cache:{user_id}:{cursor}=feed_data (TTL 5 минут)
        FeedS-->>GW: feed_items с метаданными
        GW-->>User: 200 OK
    end
```

комментарий → событие → WebSocket-уведомление.
```plantuml
sequenceDiagram
    actor User as Пользователь А
    participant GW as API Gateway
    participant Auth as Auth Service
    participant CommentS as Comment Service
    participant Cassandra as Cassandra
    participant PG as PostgreSQL
    participant EventP as Event Processor
    participant Kafka as Kafka
    actor Author as Автор поста
    participant WS as WebSocket Manager

    User->>GW: POST 
    GW->>Auth: validateToken(token)
    Auth-->>GW: user_id
    GW->>CommentS: addComment(post_id, user_id, content)
    
    CommentS->>Cassandra: INSERT INTO comments_by_post
    
    CommentS->>PG: INSERT INTO outbox_events
    
    CommentS-->>GW: 201 Created
    GW-->>User: 201 Created
    
    EventP->>PG: 
    PG-->>EventP: событие comment.created
    EventP->>PG: 
    EventP->>Kafka: publish('comment.created',<br/>{comment_id, post_id, user_id, content})
    
    NotifS->>Kafka: consumer group 'notification-service'
    Kafka-->>NotifS: событие comment.created
    
    NotifS->>Redis: GET post_author:{post_id}
    alt Автор в кэше
        Redis-->>NotifS: author_id
    else Автор не в кэше
        NotifS->>PG: SELECT author_id FROM posts WHERE id=post_id
        PG-->>NotifS: author_id
        NotifS->>Redis: SET post_author:{post_id}=author_id (TTL 1 час)
    end
    
    NotifS->>Redis: LPUSH notifications:{author_id}<br/>{type:'comment', post_id, comment_id}
    NotifS->>Redis: EXPIRE notifications:{author_id} 7 дней
    
    NotifS->>WS: sendNotification(author_id, 'new_comment')
    WS->>Author: WebSocket {event: 'new_comment',<br/>post_id: ..., comment_id: ...}
    
    Author->>GW: GET 
    GW->>NotifS: getNotifications(user_id)
    NotifS->>Redis: LRANGE notifications:{user_id} 0 49
    Redis-->>NotifS: последние 50 уведомлений
    NotifS-->>GW: notifications
    GW-->>Author: 200 OK с уведомлениями
```

```
sequenceDiagram
        actor User as Пользователь
    
        participant Gateway as API Gateway
        participant Auth as Auth Service
    
        participant PostService as Post Service
        participant FeedService as Feed Service
        participant SubService as Subscription Service
    
        participant PG as PostgreSQL
        participant Worker as Event Processor


        participant Kafka as Kafka
        participant Redis as Redis Cache
        participant Cassandra as Cassandra 
    

    Note over User: === ПУБЛИКАЦИЯ ПОСТА ===
    
    User->>Gateway: POST /api/posts {content, media}
    Gateway->>Auth: validateToken(token)
    Auth-->>Gateway: user_id
    Gateway->>PostService: createPost(user_id, content)
    
    PostService->>PG: BEGIN TRANSACTION
    PostService->>PG: INSERT INTO posts (...)
    PG-->>PostService: post_id
    PostService->>PG: INSERT INTO outbox_events (...)
    PostService->>PG: COMMIT
    PostService-->>Gateway: 201 Create + post_id 
    
    Gateway-->>User: 201 Created

    
    loop
        Worker->>PG: SELECT * FROM outbox WHERE processed=false
        PG-->>Worker: Список событий
        Worker->>PG: UPDATE outbox SET processed=true
        Worker->>Kafka: Отправить события
    end
    
    Kafka->>Worker: Получить событие "post_created"
    
    Worker->>Redis: MGET selebrity:{author_id}
    Redis-->>Worker: 
    
    alt СЕЛЕБРИТИ
        Note right of Worker: Fan-In стратегия
        Worker->>Cassandra: INSERT INTO celebrity_posts (post_id, author_id, timestamp)
    
    else ОБЫЧНЫЙ ПОЛЬЗОВАТЕЛЬ
        Note right of Worker: Fan-Out стратегия
        Worker->>SubService: get_all_followers(author_id)
        SubService-->>Worker: [follower_ids]
        Worker->>Cassandra: batch_insert(follower_ids, post_id)
    end
    
    Note over User: === ЧТЕНИЕ ЛЕНТЫ, КОГДА КЭШ ЕСТЬ===
    
    User->>Gateway: GET /api/feed?limit=20
    Gateway->>Auth: validateToken(token)
    Auth-->>Gateway: user_id
    Gateway->>FeedService: getFeed(user_id, limit=20)
    
    FeedService->>Redis: GET feed_cache: user_id
    Redis-->>FeedService: [post_ids]
    FeedService->>Redis: GET subscribe:user_id
    Redis-->>FeedService: [subscribe_user_ids]
    alt ЕСТЬ СЕЛЕБЫ В ПОДПИСКАХ
        FeedService->>Redis: GET celebrity_posts:author_id
        Redis-->>FeedService: [post_ids]
    end
    FeedService->>FeedService: Объединение списка постов 
    FeedService->>Redis: MGET post:{post_id} для каждого
    Redis-->>FeedService: [post_data]

    
    FeedService-->>Gateway: posts
    Gateway-->> User: 200 Ok
```
